// A Java project that demonstrates most of the configuration features of this
// plugin.

apply plugin: 'java'
apply plugin: 'com.google.protobuf'

sourceCompatibility = JavaVersion.VERSION_1_7
targetCompatibility = JavaVersion.VERSION_1_7

configurations {
    nanoCompile
    grpcCompile
}

sourceSets {
  nano {
    compileClasspath += configurations.nanoCompile
  }
  grpc {
    compileClasspath += configurations.grpcCompile
  }
  grpc_nano {
    compileClasspath += configurations.grpcCompile
  }
  test {
    compileClasspath += nano.output
    compileClasspath += grpc.output
    compileClasspath += grpc_nano.output
    runtimeClasspath += nano.output
    runtimeClasspath += grpc.output
    runtimeClasspath += grpc_nano.output
  }
}

def protobufDep = 'com.google.protobuf:protobuf-java:3.0.0-alpha-3'
def protobufNanoDep = 'com.google.protobuf.nano:protobuf-javanano:3.0.0-alpha-3'

dependencies {
  compile protobufDep

  protobuf files("lib/protos.tar.gz")
  protobuf fileTree("ext/") {
//    exclude 'more.proto'
  }

  testProtobuf files("lib/protos-test.tar.gz")

  testCompile 'junit:junit:4.12'
  testCompile protobufNanoDep

  nanoCompile protobufNanoDep

  grpcCompile protobufDep
  grpcCompile protobufNanoDep
  grpcCompile 'io.grpc:grpc-stub:0.7.0'
  grpcCompile 'io.grpc:grpc-protobuf:0.7.0'
  grpcCompile 'io.grpc:grpc-protobuf-nano:0.7.0'
}

protobuf {
  protoc {
    artifact = 'com.google.protobuf:protoc:3.0.0-alpha-3'
  }
  plugins {
    grpc {
      artifact = 'io.grpc:protoc-gen-grpc-java:0.7.0'
    }
  }
  generateProtoTasks {
    ofSourceSet('nano')*.builtins {
      remove java
      javanano {
        option 'java_multiple_files=false'
      }
    }
    ofSourceSet('grpc')*.plugins {
      // No options. Note the braces cannot be omitted, otherwise the plugin
      // will not be added. This is because of the implicit way
      // NamedDomainObjectContainer binds the methods.
      grpc { }
    }
    ofSourceSet('grpc_nano').each { task ->
      task.builtins {
        remove java
        javanano {
          option 'ignore_services=true'
        }
      }
      task.plugins {
        grpc {
          option 'nano=true'
          outputSubDir = 'grpcjavanano'
        }
      }
      task.generateDescriptorSet = true
    }
  }
}

// To include all sourceSets in the project jar
jar {
  sourceSets.all { sourceSet ->
    from sourceSet.output
    dependsOn sourceSet.getCompileTaskName('java')
  }
}

def assertJavaCompileHasProtoGeneratedDir(String sourceSet, Collection<String> codegenPlugins) {
  def compileJavaTask = tasks.getByName(sourceSets.getByName(sourceSet).getCompileTaskName("java"))
  assertJavaCompileHasProtoGeneratedDir(project, sourceSet, compileJavaTask, codegenPlugins)
}

def assertFileExists(boolean exists, String path) {
  if (exists) {
    assert (path as File).exists()
  } else {
    assert !(path as File).exists()
  }
}

test.doLast {
  assert ['generateProto', 'generateNanoProto', 'generateGrpcProto', 'generateGrpc_nanoProto',
          'generateTestProto'] as Set == protobuf.generateProtoTasks.all().collect({ it.name }) as Set

  assert ['generateProto'] as Set == protobuf.generateProtoTasks.ofSourceSet('main').collect({ it.name }) as Set

  assert ['generateNanoProto'] as Set == protobuf.generateProtoTasks.ofSourceSet('nano').collect({ it.name }) as Set

  assertJavaCompileHasProtoGeneratedDir('main', ['java'])
  assertJavaCompileHasProtoGeneratedDir('test', ['java'])
  assertJavaCompileHasProtoGeneratedDir('nano', ['javanano'])
  assertJavaCompileHasProtoGeneratedDir('grpc', ['java', 'grpc'])
  assertJavaCompileHasProtoGeneratedDir('grpc_nano', ['javanano', 'grpcjavanano'])

  // Check generateDescriptorSet option has been honored
  ['main', 'test', 'nano', 'grpc'].each { sourceSet ->
    assertFileExists(false, "$buildDir/generated/source/proto/$sourceSet/descriptor_set.desc")
  }
  assertFileExists(true, "$buildDir/generated/source/proto/grpc_nano/descriptor_set.desc")
}

rootProject.ext {
  // Shared test utility. Checks a JavaCompile task for the given sourceSet
  // includes the generated source dirs for the given codegenPlugins, and does
  // not include any other dirs under the generated code base dir.
  assertJavaCompileHasProtoGeneratedDir = {
      Project project, String sourceSet, JavaCompile compileJavaTask, Collection<String> codegenPlugins ->
    def baseDir = "${project.buildDir}/generated/source/proto/$sourceSet" as File
    // The expected direct subdirectories under baseDir
    def expectedDirs = codegenPlugins.collect { codegenPlugin ->
      "${project.buildDir}/generated/source/proto/$sourceSet/$codegenPlugin" as File
    } as Set

    def actualDirs = new HashSet()
    compileJavaTask.source.visit { fileVisitDetails ->
      // If the visited file is or is under a direct subdirectory of baseDir, add
      // that subdirectory to actualDirs.
      def file = fileVisitDetails.file
      while (true) {
        if (file.parentFile == baseDir) {
          actualDirs.add file
        }
        if (file.parentFile == null) {
          break
        }
        file = file.parentFile
      }
    }
    assert expectedDirs == actualDirs
  }
}
